{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/toConsumableArray.js","../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/slicedToArray.js","../../../node_modules/@babel/runtime/helpers/defineProperty.js","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../src/utils/weak-maps.ts","../src/utils/string.ts","../src/interfaces/editor.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts","../src/create-editor.ts"],"sourcesContent":["function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { createDraft, finishDraft, isDraft } from 'immer'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  Descendant,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface Editor {\n  children: Node[]\n  selection: Range | null\n  operations: Operation[]\n  marks: Record<string, any> | null\n  [key: string]: unknown\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: () => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport const Editor = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(editor: Editor): void {\n    editor.deleteFragment()\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    return (\n      isPlainObject(value) &&\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    )\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Record<string, any> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.last(editor, at)\n    const [, to] = Editor.last(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ) {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = getDirtyPaths(editor).pop()!\n        const entry = Editor.node(editor, path)\n        editor.normalizeNode(entry)\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        if (editor.isInline(node)) {\n          continue\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          const text = Editor.string(editor, { anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.first(editor, at)\n    const [, to] = Editor.first(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  string(editor: Editor, at: Location): string {\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    fn()\n    NORMALIZING.set(editor, value)\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\ntype NodeMatch<T extends Node> =\n  | ((node: Node) => node is T)\n  | ((node: Node) => boolean)\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface Element {\n  children: Node[]\n  [key: string]: unknown\n}\n\nexport const Element = {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport const Location = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport const Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Element, ElementEntry, Path, Range, Text } from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type Node = Editor | Element | Text\n\nexport const Node = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce(root, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.selection\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n","import { Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: unknown\n}\n\nexport type RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Range\n      newProperties: null\n    }\n\nexport type SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport const Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport const Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport const PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface Point {\n  path: Path\n  offset: number\n  [key: string]: unknown\n}\n\nexport const Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport const PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: unknown\n}\n\nexport const Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport const RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Range } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface Text {\n  text: string\n  [key: string]: unknown\n}\n\nexport const Text = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    for (const key in text) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    for (const key in another) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= offset + length) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range starts after the leaf, or ends before it, continue.\n        if (\n          start.offset > offset + length ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < offset + length) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport const GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\n\nexport const NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n =>\n          levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const { text, children, ...properties } = node\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path) as NodeEntry<Ancestor>\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry as NodeEntry<Ancestor>\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport const SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor) {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location) {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>) {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport const TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: () => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor)\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const child = node.children[i] as Descendant\n        const prev = node.children[i - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n"],"names":["DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","text","offset","prev","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","length","i","started","char","charAt","l","slice","rest","isWordCharacter","remaining","test","next","code","Editor","above","editor","options","voids","mode","at","selection","match","path","reverse","levels","n","p","Text","isText","Path","equals","addMark","key","value","after","anchor","point","edge","focus","end","range","distance","d","target","positions","before","start","deleteBackward","unit","deleteForward","deleteFragment","edges","first","node","fragment","Node","hasBlocks","element","children","some","isBlock","hasInlines","isInline","hasTexts","every","insertBreak","insertFragment","insertNode","insertText","Element","isElement","isEditor","isPlainObject","apply","isVoid","normalizeNode","onChange","removeMark","marks","Range","isRange","isNodeList","Operation","isOperationList","operations","isEnd","Point","isEdge","isStart","isEmpty","isNormalizing","get","undefined","last","leaf","push","isExpanded","nodes","previous","block","prevNode","prevPath","blockPath","isAncestor","from","to","span","isPath","Error","parent","includes","universal","Span","isSpan","nodeEntries","pass","matches","hit","isLower","compare","emit","normalize","force","getDirtyPaths","allPaths","Array","set","withoutNormalizing","max","m","pop","entry","parentPath","depth","firstPath","lastPath","common","isPoint","pathRef","affinity","ref","current","unref","pathRefs","refs","add","Set","pointRef","pointRefs","string","available","isNewBlock","advance","e","s","reverseText","isFirst","rangeRef","rangeRefs","t","unhangRange","isCollapsed","endBlock","skip","isBefore","fn","isElementList","isArray","props","Location","isLocation","ancestor","root","ancestors","child","index","JSON","stringify","c","childPath","concat","another","descendant","descendants","elements","newRoot","produce","r","splice","has","isNode","visited","isAfter","nextIndex","newPath","map","join","texts","isNodeOperation","isOperation","type","endsWith","position","properties","newProperties","isSelectionOperation","isTextOperation","inverse","op","isSibling","inversePath","transform","inverseNewPath","paths","av","bv","min","Math","endsAfter","as","bs","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","al","bl","list","relative","operation","onp","copy","PathRef","result","PointRef","isBackward","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isForward","points","affinityAnchor","affinityFocus","RangeRef","loose","isTextList","decorations","leaves","dec","o","Object","assign","middle","off","GeneralTransforms","createDraft","truePath","newParent","newIndex","newNode","finishDraft","isDraft","NodeTransforms","insertNodes","hanging","select","Transforms","matchPath","isAtEnd","splitNodes","liftNodes","parentNodeEntry","toPath","moveNodes","removeNodes","splitPath","mergeNodes","commonPath","isPreviousSibling","emptyAncestor","emptyRef","toRef","targets","depths","setNodes","split","splitMode","k","keys","height","always","deleteRange","beforeRef","highest","voidMatch","nudge","voidNode","voidPath","afterPath","siblingHeight","afterRef","highestPath","lowestPath","unsetNodes","obj","unwrapNodes","wrapNodes","roots","rootPath","a","commonNodeEntry","commonNode","wrapperPath","wrapper","SelectionTransforms","collapse","deselect","move","opts","setSelection","setPoint","oldProps","newProps","TextTransforms","furthestVoid","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","inlinePath","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef","createEditor","dirtyPaths","oldDirtyPaths","newDirtyPaths","Promise","resolve","then","getFragment","inline","shouldHaveInlines","isLast","isInlineOrText","newChild","previousPath","oldAncestors","newAncestors","nextPath"],"mappings":"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"}